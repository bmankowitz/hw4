//
// Generated by JTB 1.3.2
//

package hw3;
import minijava.syntaxtree.*;

import java.util.*;
import hw3.*;
import minijava.visitor.Visitor;

/**
 * Provides default methods which visit each node in the tree in depth-first
 * order.  Your visitors may extend this class.
 */

public class TreeCheckingVisitor implements Visitor {
    enum type {
        BOOLEAN,
        INTEGER,
        INTEGER_ARRAY,
        OBJECT
    }
    public ArrayList<ClassDeclaration> objects;
    public HashMap<LinkedList<String>, ArrayList<Var>> vars = new HashMap<>();
    public LinkedList<String> currentLocation = new LinkedList<>();
    public int line = 1;
    public TreeCheckingVisitor(HashMap<LinkedList<String>, ArrayList<Var>> vars){
        this.vars = vars;
    }
    public Var checkVarExists(LinkedList<String> location, Identifier identifier){
        //1. Make sure this var exists
        LinkedList<String> tempLoc = new LinkedList<>(location);
        while(!tempLoc.isEmpty()){
            if(vars.get(tempLoc) != null && !vars.get(tempLoc).isEmpty()){
                for(Var v : vars.get(tempLoc)){
                    if(v.identifier.f0.tokenImage.equals(identifier.f0.tokenImage)){
                        //found the Var!
                        return v;
                    }
                }
            }
            tempLoc.removeLast();
        }
        //reached the root without finding the Var
        throw new TypeError("Unable to find Var named: " + identifier.f0.tokenImage + " at line "
                + identifier.f0.beginLine + " column " + identifier.f0.beginColumn);
    }
    public type getEquivalentType(Object obj){
        if(obj instanceof TrueLiteral || obj instanceof FalseLiteral || obj instanceof BooleanType) return type.BOOLEAN;
        else if(obj instanceof IntegerLiteral || obj instanceof IntegerType) return type.INTEGER;
        else if(obj instanceof ArrayType) return type.INTEGER_ARRAY;
        else if(obj instanceof Var) return getEquivalentType(((Var) obj).type.f0.choice);
        else if(obj instanceof Expression) return evalExpressionType((Expression) obj, null);
        else if(obj instanceof PrimaryExpression) return evalPrimaryExpression((PrimaryExpression) obj, null);
        else if(obj instanceof Type) return getEquivalentType(((Type) obj).f0.choice);
        else return null;
    }

    public void checkVarType(Var var, type expectedType){
        if(getEquivalentType(var.type.f0.choice) != expectedType)
            throw new TypeError("Expected type " + expectedType + " but found type " +
                    getEquivalentType(var.type.f0.choice) + " on var name " + var.identifier.f0.tokenImage + " on line " + line );
    }
    public void checkVarType(type actual, type expectedType){
        if(actual != expectedType)
            throw new TypeError("Expected type " + expectedType + " but found type " +
                    actual + " on var name " +  " on line " + line );
    }
    public type checkType(PrimaryExpression p1, PrimaryExpression p2, int line, int column){
        if(evalPrimaryExpression(p1, null) != evalPrimaryExpression(p2, null))
            throw new TypeError("Expression argument mismatch. Argument 1 of type " + evalPrimaryExpression(p1, null)
                    + " but argument 2 of type " + evalPrimaryExpression(p2, null) + " on line " + line +
                    " column "+column);
        else return evalPrimaryExpression(p1, null);
    }
    public type evalExpressionType(Expression expr, Var var){
        if(expr.f0.choice instanceof PlusExpression){
            PrimaryExpression p1 = ((PlusExpression) expr.f0.choice).f0;
            NodeToken plus = ((PlusExpression) expr.f0.choice).f1;
            PrimaryExpression p2 = ((PlusExpression) expr.f0.choice).f2;
            return checkType(p1, p2, plus.beginLine, plus.beginColumn);
        }
        if(expr.f0.choice instanceof MinusExpression){
            PrimaryExpression p1 = ((MinusExpression) expr.f0.choice).f0;
            NodeToken minus = ((MinusExpression) expr.f0.choice).f1;
            PrimaryExpression p2 = ((MinusExpression) expr.f0.choice).f2;
            return checkType(p1, p2, minus.beginLine, minus.beginColumn);
        }
        if(expr.f0.choice instanceof TimesExpression){
            PrimaryExpression p1 = ((TimesExpression) expr.f0.choice).f0;
            NodeToken times = ((TimesExpression) expr.f0.choice).f1;
            PrimaryExpression p2 = ((TimesExpression) expr.f0.choice).f2;
            return checkType(p1, p2, times.beginLine, times.beginColumn);
        }
        if(expr.f0.choice instanceof MessageSend){
            String path = "this";
            //if this method call has other message paths, the path will change
            try {
                Var possibleVar = checkVarExists(currentLocation,((Identifier) ((MessageSend) expr.f0.choice).f0.f0.choice));
                if(possibleVar != null)
                    path = possibleVar.objectLocationAlias.getFirst();
                else path = ((Identifier) ((MessageSend) expr.f0.choice).f0.f0.choice).f0.tokenImage;
            }
            catch (Exception ignored){};
            Var method;
            if(!path.equals("this")){
                method = checkVarExists(new LinkedList<String>(Arrays.asList(path)), ((MessageSend) expr.f0.choice).f2);
            }
            else method = checkVarExists(currentLocation, ((MessageSend) expr.f0.choice).f2);
            if(var != null) checkVarType(method, getEquivalentType(var));
            //check that the var we found is actually a method. If the params is an empty arraylist - method. null = var
            if(method.parameters == null){
                throw new TypeError("Expected method but var " +method.identifier.f0.tokenImage+ " was of type " +
                        getEquivalentType(method) + " on line " +((MessageSend) expr.f0.choice).f1.beginLine +
                        " column " + (((MessageSend) expr.f0.choice).f1.beginColumn + 1));
            }
            //if(method.identifier.f0.)
            //now we need to check the arguments:
            //create arrayList of parameters:
            try {
                ArrayList<Expression> params = new ArrayList<>();
                if (((MessageSend) expr.f0.choice).f4 != null) {
                    ExpressionList expressionList = (ExpressionList) ((MessageSend) expr.f0.choice).f4.node;
                    //add first param:
                    if (((MessageSend) expr.f0.choice).f4 != null)
                        params.add(((ExpressionList) ((MessageSend) expr.f0.choice).f4.node).f0);
                    for (Node node : ((ExpressionList) ((MessageSend) expr.f0.choice).f4.node).f1.nodes) {
                        ExpressionRest node1 = (ExpressionRest) node;
                        params.add(node1.f1);
                    }
                }
                //assert that each param is of the required type:
                if (params.size() != method.parameters.size())
                    throw new TypeError("Parameter number mismatch on " + var.identifier.f0.tokenImage +
                            " on line " + ((MessageSend) expr.f0.choice).f1.beginLine);
                for (int i = 0; i < params.size(); i++) {
                    evalExpressionType(params.get(i), method.parameters.get(i));
                }
            } catch(NullPointerException ignored){};
            return getEquivalentType(method);
        }
        if(expr.f0.choice instanceof ArrayLookup){
            Identifier id = (Identifier) ((ArrayLookup) expr.f0.choice).f0.f0.choice;
            PrimaryExpression arrayLocation = ((ArrayLookup) expr.f0.choice).f2;
            Var array = checkVarExists(currentLocation, id);
            checkVarType(array, type.INTEGER_ARRAY);
            checkVarType(evalPrimaryExpression(arrayLocation, null), type.INTEGER);
            return type.INTEGER;
        }
        //else if(expr.f0.choice )

        else if(expr.f0.choice instanceof PrimaryExpression){
            return evalPrimaryExpression((PrimaryExpression) expr.f0.choice, var);
        }
        //else if()
        return  null;
    }
    public type evalPrimaryExpression(PrimaryExpression pExpr, Var var){
        if(pExpr.f0.choice instanceof BracketExpression){
            return evalExpressionType(((BracketExpression) pExpr.f0.choice).f1, var);
        }
        else{
            if(pExpr.f0.choice instanceof PrimaryExpression)
                return evalPrimaryExpression((PrimaryExpression) pExpr.f0.choice, var);
            else if(pExpr.f0.choice instanceof Identifier){
                Var exists = checkVarExists(currentLocation, (Identifier) pExpr.f0.choice);
                return getEquivalentType(exists);
            }
            else if(pExpr.f0.choice instanceof ArrayAllocationExpression){
                checkVarType(evalPrimaryExpression((PrimaryExpression) ((ArrayAllocationExpression) pExpr.f0.choice).f3.f0.choice, null), type.INTEGER);
                return type.INTEGER_ARRAY;
            }
            if(var != null) checkVarType(var, getEquivalentType(pExpr));
            return getEquivalentType(pExpr.f0.choice);
        }

    }
    //
    // Auto class visitors--probably don't need to be overridden.
    //
    public void visit(NodeList n) {
        for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); )
            e.nextElement().accept(this);
    }

    public void visit(NodeListOptional n) {
        if ( n.present() )
            for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); )
                e.nextElement().accept(this);
    }

    public void visit(NodeOptional n) {
        if ( n.present() )
            n.node.accept(this);
    }

    public void visit(NodeSequence n) {
        for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); )
            e.nextElement().accept(this);
    }

    public void visit(NodeToken n) { }

    //
    // User-generated visitor methods below
    //

    /**
     * <PRE>
     * f0 -> MainClass()
     * f1 -> ( TypeDeclaration() )*
     * f2 -> &lt;EOF&gt;
     * </PRE>
     */
    public void visit(Goal n) {
        n.f0.accept(this);
        n.f1.accept(this);
        n.f2.accept(this);
    }

    /**
     * <PRE>
     * f0 -> "class"
     * f1 -> Identifier()
     * f2 -> "{"
     * f3 -> "public"
     * f4 -> "static"
     * f5 -> "void"
     * f6 -> "main"
     * f7 -> "("
     * f8 -> "String"
     * f9 -> "["
     * f10 -> "]"
     * f11 -> Identifier()
     * f12 -> ")"
     * f13 -> "{"
     * f14 -> ( VarDeclaration() )*
     * f15 -> ( Statement() )*
     * f16 -> "}"
     * f17 -> "}"
     * </PRE>
     */
    public void visit(MainClass n) {
        n.f0.accept(this);
        n.f1.accept(this);
        n.f2.accept(this);
        n.f3.accept(this);
        n.f4.accept(this);
        n.f5.accept(this);
        n.f6.accept(this);
        n.f7.accept(this);
        n.f8.accept(this);
        n.f9.accept(this);
        n.f10.accept(this);
        n.f11.accept(this);
        n.f12.accept(this);
        n.f13.accept(this);
        n.f14.accept(this);
        n.f15.accept(this);
        n.f16.accept(this);
        n.f17.accept(this);
    }

    /**
     * <PRE>
     * f0 -> ClassDeclaration()
     *       | ClassExtendsDeclaration()
     * </PRE>
     */
    public void visit(TypeDeclaration n) {
        n.f0.accept(this);
    }

    /**
     * <PRE>
     * f0 -> "class"
     * f1 -> Identifier()
     * f2 -> "{"
     * f3 -> ( VarDeclaration() )*
     * f4 -> ( MethodDeclaration() )*
     * f5 -> "}"
     * </PRE>
     */
    public void visit(ClassDeclaration n) {
        n.f0.accept(this);
        n.f1.accept(this);
        n.f2.accept(this);
        currentLocation.add(n.f1.f0.toString());
        n.f3.accept(this);
        n.f4.accept(this);
        currentLocation.remove(currentLocation.size() - 1);
        n.f5.accept(this);
    }

    /**
     * <PRE>
     * f0 -> "class"
     * f1 -> Identifier()
     * f2 -> "extends"
     * f3 -> Identifier()
     * f4 -> "{"
     * f5 -> ( VarDeclaration() )*
     * f6 -> ( MethodDeclaration() )*
     * f7 -> "}"
     * </PRE>
     */
    public void visit(ClassExtendsDeclaration n) {
        n.f0.accept(this);
        n.f1.accept(this);
        n.f2.accept(this);
        n.f3.accept(this);
        n.f4.accept(this);
        currentLocation.add(n.f1.f0.toString());
        n.f5.accept(this);
        n.f6.accept(this);
        currentLocation.remove(currentLocation.size() - 1);
        n.f7.accept(this);
    }

    /**
     * <PRE>
     * f0 -> Type()
     * f1 -> Identifier()
     * f2 -> ";"
     * </PRE>
     */
    public void visit(VarDeclaration n) {
        n.f0.accept(this);
        n.f1.accept(this);
        n.f2.accept(this);
    }

    /**
     * <PRE>
     * f0 -> "public"
     * f1 -> Type()
     * f2 -> Identifier()
     * f3 -> "("
     * f4 -> ( FormalParameterList() )?
     * f5 -> ")"
     * f6 -> "{"
     * f7 -> ( VarDeclaration() )*
     * f8 -> ( Statement() )*
     * f9 -> "return"
     * f10 -> Expression()
     * f11 -> ";"
     * f12 -> "}"
     * </PRE>
     */
    public void visit(MethodDeclaration n) {
        n.f0.accept(this);
        n.f1.accept(this);
        n.f2.accept(this);
        n.f3.accept(this);
        n.f4.accept(this);
        n.f5.accept(this);
        n.f6.accept(this);
        currentLocation.add(n.f2.f0.toString());
        n.f7.accept(this);
        n.f8.accept(this);
        n.f9.accept(this);
        n.f10.accept(this);
        n.f11.accept(this);
        //ensure return type is the same as the declared type:
        line = n.f9.beginLine;
        checkVarType(getEquivalentType(n.f10), getEquivalentType(n.f1));
        currentLocation.remove(currentLocation.size() - 1);
        n.f12.accept(this);
    }

    /**
     * <PRE>
     * f0 -> FormalParameter()
     * f1 -> ( FormalParameterRest() )*
     * </PRE>
     */
    public void visit(FormalParameterList n) {
        n.f0.accept(this);
        n.f1.accept(this);
    }

    /**
     * <PRE>
     * f0 -> Type()
     * f1 -> Identifier()
     * </PRE>
     */
    public void visit(FormalParameter n) {
        n.f0.accept(this);
        n.f1.accept(this);
    }

    /**
     * <PRE>
     * f0 -> ","
     * f1 -> FormalParameter()
     * </PRE>
     */
    public void visit(FormalParameterRest n) {
        n.f0.accept(this);
        n.f1.accept(this);
    }

    /**
     * <PRE>
     * f0 -> ArrayType()
     *       | BooleanType()
     *       | IntegerType()
     *       | Identifier()
     * </PRE>
     */
    public void visit(Type n) {
        n.f0.accept(this);
    }

    /**
     * <PRE>
     * f0 -> "int"
     * f1 -> "["
     * f2 -> "]"
     * </PRE>
     */
    public void visit(ArrayType n) {
        n.f0.accept(this);
        n.f1.accept(this);
        n.f2.accept(this);
    }

    /**
     * <PRE>
     * f0 -> "boolean"
     * </PRE>
     */
    public void visit(BooleanType n) {
        n.f0.accept(this);
    }

    /**
     * <PRE>
     * f0 -> "int"
     * </PRE>
     */
    public void visit(IntegerType n) {
        n.f0.accept(this);
    }

    /**
     * <PRE>
     * f0 -> Block()
     *       | AssignmentStatement()
     *       | ArrayAssignmentStatement()
     *       | IfStatement()
     *       | WhileStatement()
     *       | PrintStatement()
     * </PRE>
     */
    public void visit(Statement n) {
        n.f0.accept(this);
    }

    /**
     * <PRE>
     * f0 -> "{"
     * f1 -> ( Statement() )*
     * f2 -> "}"
     * </PRE>
     */
    public void visit(Block n) {
        n.f0.accept(this);
        currentLocation.add(n.f0.toString());
        n.f1.accept(this);
        currentLocation.remove(currentLocation.size() - 1);
        n.f2.accept(this);
    }

    /**
     * <PRE>
     * f0 -> Identifier()
     * f1 -> "="
     * f2 -> Expression()
     * f3 -> ";"
     * </PRE>
     */
    public void visit(AssignmentStatement n) {
        n.f0.accept(this);
        //check if var exists:
        Var var = checkVarExists(currentLocation, n.f0);
        n.f1.accept(this);
        n.f2.accept(this);
        line = n.f1.beginLine;
        checkVarType(var, evalExpressionType(n.f2, var));

        n.f3.accept(this);
    }

    /**
     * <PRE>
     * f0 -> Identifier()
     * f1 -> "["
     * f2 -> Expression()
     * f3 -> "]"
     * f4 -> "="
     * f5 -> Expression()
     * f6 -> ";"
     * </PRE>
     */
    public void visit(ArrayAssignmentStatement n) {
        n.f0.accept(this);
        //check if var exists:
        Var var = checkVarExists(currentLocation, n.f0);
        line = n.f1.beginLine;
        checkVarType(var, type.INTEGER_ARRAY);
        n.f1.accept(this);
        n.f2.accept(this);
        checkVarType(evalExpressionType(n.f2, null), type.INTEGER);
        n.f3.accept(this);
        n.f4.accept(this);
        n.f5.accept(this);
        checkVarType(evalExpressionType(n.f5, null), type.INTEGER);
        n.f6.accept(this);
    }

    /**
     * <PRE>
     * f0 -> "if"
     * f1 -> "("
     * f2 -> Expression()
     * f3 -> ")"
     * f4 -> Statement()
     * f5 -> "else"
     * f6 -> Statement()
     * </PRE>
     */
    public void visit(IfStatement n) {
        n.f0.accept(this);
        n.f1.accept(this);
        n.f2.accept(this);
        n.f3.accept(this);
        n.f4.accept(this);
        n.f5.accept(this);
        n.f6.accept(this);
    }

    /**
     * <PRE>
     * f0 -> "while"
     * f1 -> "("
     * f2 -> Expression()
     * f3 -> ")"
     * f4 -> Statement()
     * </PRE>
     */
    public void visit(WhileStatement n) {
        n.f0.accept(this);
        n.f1.accept(this);
        n.f2.accept(this);
        n.f3.accept(this);
        n.f4.accept(this);
    }

    /**
     * <PRE>
     * f0 -> "System.out.println"
     * f1 -> "("
     * f2 -> Expression()
     * f3 -> ")"
     * f4 -> ";"
     * </PRE>
     */
    public void visit(PrintStatement n) {
        n.f0.accept(this);
        n.f1.accept(this);
        n.f2.accept(this);
        n.f3.accept(this);
        n.f4.accept(this);
    }

    /**
     * <PRE>
     * f0 -> AndExpression()
     *       | CompareExpression()
     *       | PlusExpression()
     *       | MinusExpression()
     *       | TimesExpression()
     *       | ArrayLookup()
     *       | ArrayLength()
     *       | MessageSend()
     *       | PrimaryExpression()
     * </PRE>
     */
    public void visit(Expression n) {
        n.f0.accept(this);
    }

    /**
     * <PRE>
     * f0 -> PrimaryExpression()
     * f1 -> "&&"
     * f2 -> PrimaryExpression()
     * </PRE>
     */
    public void visit(AndExpression n) {
        n.f0.accept(this);
        n.f1.accept(this);
        n.f2.accept(this);
    }

    /**
     * <PRE>
     * f0 -> PrimaryExpression()
     * f1 -> "&lt;"
     * f2 -> PrimaryExpression()
     * </PRE>
     */
    public void visit(CompareExpression n) {
        n.f0.accept(this);
        n.f1.accept(this);
        n.f2.accept(this);
    }

    /**
     * <PRE>
     * f0 -> PrimaryExpression()
     * f1 -> "+"
     * f2 -> PrimaryExpression()
     * </PRE>
     */
    public void visit(PlusExpression n) {
        n.f0.accept(this);
        n.f1.accept(this);
        n.f2.accept(this);
    }

    /**
     * <PRE>
     * f0 -> PrimaryExpression()
     * f1 -> "-"
     * f2 -> PrimaryExpression()
     * </PRE>
     */
    public void visit(MinusExpression n) {
        n.f0.accept(this);
        n.f1.accept(this);
        n.f2.accept(this);
    }

    /**
     * <PRE>
     * f0 -> PrimaryExpression()
     * f1 -> "*"
     * f2 -> PrimaryExpression()
     * </PRE>
     */
    public void visit(TimesExpression n) {
        n.f0.accept(this);
        n.f1.accept(this);
        n.f2.accept(this);
    }

    /**
     * <PRE>
     * f0 -> PrimaryExpression()
     * f1 -> "["
     * f2 -> PrimaryExpression()
     * f3 -> "]"
     * </PRE>
     */
    public void visit(ArrayLookup n) {
        n.f0.accept(this);
        n.f1.accept(this);
        n.f2.accept(this);
        n.f3.accept(this);
    }

    /**
     * <PRE>
     * f0 -> PrimaryExpression()
     * f1 -> "."
     * f2 -> "length"
     * </PRE>
     */
    public void visit(ArrayLength n) {
        n.f0.accept(this);
        n.f1.accept(this);
        n.f2.accept(this);
    }

    /**
     * <PRE>
     * f0 -> PrimaryExpression()
     * f1 -> "."
     * f2 -> Identifier()
     * f3 -> "("
     * f4 -> ( ExpressionList() )?
     * f5 -> ")"
     * </PRE>
     */
    public void visit(MessageSend n) {
        n.f0.accept(this);
        n.f1.accept(this);
        n.f2.accept(this);
        n.f3.accept(this);
        n.f4.accept(this);
        n.f5.accept(this);
    }

    /**
     * <PRE>
     * f0 -> Expression()
     * f1 -> ( ExpressionRest() )*
     * </PRE>
     */
    public void visit(ExpressionList n) {
        n.f0.accept(this);
        n.f1.accept(this);
    }

    /**
     * <PRE>
     * f0 -> ","
     * f1 -> Expression()
     * </PRE>
     */
    public void visit(ExpressionRest n) {
        n.f0.accept(this);
        n.f1.accept(this);
    }

    /**
     * <PRE>
     * f0 -> IntegerLiteral()
     *       | TrueLiteral()
     *       | FalseLiteral()
     *       | Identifier()
     *       | ThisExpression()
     *       | ArrayAllocationExpression()
     *       | AllocationExpression()
     *       | NotExpression()
     *       | BracketExpression()
     * </PRE>
     */
    public void visit(PrimaryExpression n) {
        n.f0.accept(this);
    }

    /**
     * <PRE>
     * f0 -> &lt;INTEGER_LITERAL&gt;
     * </PRE>
     */
    public void visit(IntegerLiteral n) {
        n.f0.accept(this);
    }

    /**
     * <PRE>
     * f0 -> "true"
     * </PRE>
     */
    public void visit(TrueLiteral n) {
        n.f0.accept(this);
    }

    /**
     * <PRE>
     * f0 -> "false"
     * </PRE>
     */
    public void visit(FalseLiteral n) {
        n.f0.accept(this);
    }

    /**
     * <PRE>
     * f0 -> &lt;IDENTIFIER&gt;
     * </PRE>
     */
    public void visit(Identifier n) {
        n.f0.accept(this);
    }

    /**
     * <PRE>
     * f0 -> "this"
     * </PRE>
     */
    public void visit(ThisExpression n) {
        n.f0.accept(this);
    }

    /**
     * <PRE>
     * f0 -> "new"
     * f1 -> "int"
     * f2 -> "["
     * f3 -> Expression()
     * f4 -> "]"
     * </PRE>
     */
    public void visit(ArrayAllocationExpression n) {
        n.f0.accept(this);
        n.f1.accept(this);
        n.f2.accept(this);
        n.f3.accept(this);
        n.f4.accept(this);
    }

    /**
     * <PRE>
     * f0 -> "new"
     * f1 -> Identifier()
     * f2 -> "("
     * f3 -> ")"
     * </PRE>
     */
    public void visit(AllocationExpression n) {
        n.f0.accept(this);
        n.f1.accept(this);
        n.f2.accept(this);
        n.f3.accept(this);
    }

    /**
     * <PRE>
     * f0 -> "!"
     * f1 -> Expression()
     * </PRE>
     */
    public void visit(NotExpression n) {
        n.f0.accept(this);
        n.f1.accept(this);
    }

    /**
     * <PRE>
     * f0 -> "("
     * f1 -> Expression()
     * f2 -> ")"
     * </PRE>
     */
    public void visit(BracketExpression n) {
        n.f0.accept(this);
        n.f1.accept(this);
        n.f2.accept(this);
    }

}
